# Story 5.4: API Integration Hook

**Epic:** Epic 5 - Intake & Results UI
**Status:** Ready for Review
**Priority:** P0 - Core Feature
**Complexity:** Medium
**Owner:** Dev Team

---

## User Story

As a developer, I need a custom React hook that handles all API communication with the recommendation engine, including request submission, response parsing, and error handling, so that UI components can easily trigger recommendations without managing HTTP details.

---

## Acceptance Criteria

### Hook Exports & API

- [ ] Create `src/ui/hooks/useRecommendation.ts` custom hook
- [ ] Hook exports main function: `useRecommendation()`
- [ ] Hook returns object with: `submit`, `result`, `stages`, `loading`, `error`
- [ ] All return values typed with TypeScript interfaces
- [ ] Hook uses React hooks internally (useState, useEffect, useCallback)
- [ ] TypeScript strict mode enabled throughout

### Submit Function

- [ ] `submit()` function accepts IntakeRequest object as parameter
- [ ] IntakeRequest includes: usage (kWh), supplier, rate, contract date, preferences
- [ ] submit() returns Promise that resolves when recommendation received
- [ ] submit() sends POST request to `/api/recommend` endpoint
- [ ] Request body includes all intake data in correct format
- [ ] Content-Type header: "application/json"
- [ ] Request includes proper error boundary handling
- [ ] submit() disables until current request completes

### Response Handling

- [ ] Hook receives response from `/api/recommend` API
- [ ] Response includes: recommendations[], stages[], metadata
- [ ] Parses recommendations array (top 3 plans with details)
- [ ] Parses stages array (Usage Summary, Plan Scoring, Narrative Generation)
- [ ] Extracts metadata: requestId, timestamp, duration
- [ ] Validates response structure before updating state
- [ ] Handles malformed JSON gracefully (error state)
- [ ] Updates result state with parsed recommendations

### Stages State Management

- [ ] `stages` state array tracks AI pipeline progress
- [ ] Each stage object: name, status, startTime, endTime, output, error
- [ ] Stage status enum: "queued", "running", "completed", "error"
- [ ] Stages initialized as: queued state for all 3 stages
- [ ] Phase 1: Optimistic update - advance stages on schedule
  - Stage 1 (Usage Summary): complete after 2-3 seconds
  - Stage 2 (Plan Scoring): complete after 5-7 seconds
  - Stage 3 (Narrative Generation): complete after 8-10 seconds
- [ ] Phase 2 ready: Can switch to SSE updates (feature detection)
- [ ] Stages update reactively (component re-renders on change)
- [ ] Timestamps recorded for each stage transition
- [ ] Output field updated if available from response

### Result State

- [ ] `result` state contains recommendations array
- [ ] Initial value: null (no recommendation yet)
- [ ] After submit success: result = { recommendations: [...], metadata: {...} }
- [ ] Recommendations sorted by savings (highest first)
- [ ] Each recommendation includes: supplier, plan, savings, contract, fee, renewable, narrative
- [ ] result structure validated against interface
- [ ] Persists until "reset" action (handled by parent component)

### Loading State

- [ ] `loading` boolean: true when request in flight, false otherwise
- [ ] Initial value: false
- [ ] Set to true when submit() called
- [ ] Set to false when response received (success or error)
- [ ] Parent uses loading state to disable form, show spinner
- [ ] Loading state drives ProgressTimeline display

### Error State

- [ ] `error` state: null initially, string message on error
- [ ] Captures network errors: "Network error: unable to reach server"
- [ ] Captures API errors: "API error: {status code} {message}"
- [ ] Captures validation errors: "Invalid response format"
- [ ] Captures timeout errors: "Request timeout after 30 seconds"
- [ ] Error messages user-friendly (no raw stack traces)
- [ ] Clear error method: set error to null on retry
- [ ] Parent components display error message with retry button

### Retry Capability

- [ ] submit() can be called again after error
- [ ] Calling submit() clears previous error state
- [ ] Retry preserves original intake data
- [ ] No need for user to re-enter form data
- [ ] Retry logic: simple retry limit (max 3 attempts per session)
- [ ] After max retries, disable retry and show final error
- [ ] Track retry attempt count in hook state

### Optimistic UI (Phase 1)

- [ ] Initial stages: all "queued" when submit() called
- [ ] After 1-2 seconds: Stage 1 transitions to "running"
- [ ] After 2-3 seconds: Stage 1 complete, Stage 2 running
- [ ] After 5-7 seconds: Stage 2 complete, Stage 3 running
- [ ] After 8-10 seconds: Stage 3 complete, show result
- [ ] Timing controlled via constants (testable):
  ```
  const STAGE_TIMINGS = {
    STAGE_1: 2500, // ms
    STAGE_2: 4000, // ms
    STAGE_3: 2500  // ms
  }
  ```
- [ ] Use setTimeout for optimistic timing
- [ ] Clear timeouts on unmount or retry

### SSE Feature Detection (Phase 2 Ready)

- [ ] Hook detects if API supports Server-Sent Events (SSE)
- [ ] Optional: check response headers or initial response for SSE flag
- [ ] If SSE available: override optimistic timing with real updates
- [ ] If SSE unavailable: fall back to optimistic timing
- [ ] No breaking changes to hook API for Phase 2 transition
- [ ] Comments indicate Phase 2 SSE implementation points

### Request/Response Validation

- [ ] Validate intake data before POST:
  - kWh: number, 0-999,999
  - supplier: non-empty string
  - rate: number, 0.01-1.00
  - contractDate: valid date format (ISO 8601)
  - preferences: object with valid values
- [ ] Reject invalid data with error state
- [ ] Validate API response schema:
  - recommendations: array of objects
  - each recommendation has required fields
  - stages: array with 3 stage objects
  - metadata: object with requestId, timestamp
- [ ] Reject invalid response with error state
- [ ] Log validation errors for debugging

### Error Boundary Integration

- [ ] Hook catches and handles async errors
- [ ] No unhandled promise rejections
- [ ] Errors surface via error state (not thrown)
- [ ] Component can handle error gracefully
- [ ] Error doesn't crash app

### Cleanup & Unmounting

- [ ] Hook clears all timers on unmount
- [ ] Hook aborts fetch requests on unmount (if using AbortController)
- [ ] No memory leaks from dangling listeners
- [ ] Can remount hook without side effects
- [ ] Calling submit() after unmount is safe (no-op)

### TypeScript Definitions

- [ ] IntakeRequest interface defined
  ```typescript
  interface IntakeRequest {
    usage: number;
    supplier: string;
    rate: number;
    contractDate: string;
    preferences: { ... };
  }
  ```
- [ ] Recommendation interface defined
  ```typescript
  interface Recommendation {
    supplier: string;
    plan: string;
    savings: number;
    // ... other fields
  }
  ```
- [ ] Stage interface defined
  ```typescript
  interface Stage {
    name: string;
    status: "queued" | "running" | "completed" | "error";
    // ... timestamps, output
  }
  ```
- [ ] Hook return type fully typed
  - submit: (intake: IntakeRequest) => Promise<void>
  - result: RecommendationResult | null
  - stages: Stage[]
  - loading: boolean
  - error: string | null

### Code Quality

- [ ] Hook file: ~300 lines including types
- [ ] Clear separation: request, response, state logic
- [ ] Comments explain optimistic timing and Phase 2 readiness
- [ ] No external dependencies beyond React
- [ ] Constants extracted (endpoints, timeouts, stage timings)
- [ ] Pure function approach where possible
- [ ] useCallback memoizes submit function
- [ ] No unnecessary re-renders (dependency arrays correct)

### Integration Points

- [ ] Hook consumed by IntakeForm component (5.1)
- [ ] Hook consumed by App.tsx for state orchestration
- [ ] stages prop passed to ProgressTimeline (5.2)
- [ ] result prop passed to RecommendationDeck (5.3)
- [ ] loading prop used for form disable/spinner
- [ ] error prop displayed in error UI
- [ ] submit callback triggered from IntakeForm

---

## Implementation Details

### Tasks / Subtasks

1. Create hook file:
   - Create `src/ui/hooks/` directory if needed
   - Create `src/ui/hooks/useRecommendation.ts`

2. Define TypeScript types:
   - IntakeRequest interface (usage, supplier, rate, contractDate, preferences)
   - Recommendation interface (all fields needed for display)
   - Stage interface (name, status, timestamps, output)
   - RecommendationResult interface (recommendations[], metadata)
   - Return type interface for hook

3. Build hook logic:
   - useState for result, stages, loading, error
   - useCallback for submit function
   - useEffect for cleanup (timers, abort)

4. Implement optimistic timing:
   - Stage timing constants
   - setTimeout schedule for stage transitions
   - Stage update logic

5. Implement API integration:
   - Fetch POST to /api/recommend
   - Request validation
   - Response parsing and validation
   - Error handling

6. Add retry logic:
   - Track retry count
   - Implement retry limit
   - Clear error on retry

7. Test coverage:
   - Hook returns correct initial state
   - submit() sends proper request
   - Stages advance on schedule (optimistic)
   - Error handling works correctly
   - Cleanup on unmount works
   - TypeScript compilation passes

### Technical Summary

This story delivers the API integration layer, providing:
- Custom React hook for recommendation engine communication
- Request/response validation
- Optimistic UI updates (Phase 1)
- Real-time update ready (Phase 2 SSE detection)
- Error handling and retry capability
- Full TypeScript typing
- Clean component interface

---

## Context References

**Tech-Spec:** [tech-spec.md](../docs/tech-spec.md) - Implementation Details covers:
- API endpoint: POST `/api/recommend`
- Request/response schema
- Error handling patterns
- Phase 1 optimistic timing
- Phase 2 SSE feature detection

**Architecture:** Hook bridges UI and API:
- Input: intake data from IntakeForm
- Output: recommendations and stages for display
- Integration: consumed by App.tsx and all UI components

**Dependencies:**
- React 19+ (hooks)
- Fetch API (native, no axios needed)
- TypeScript strict mode
- Mock API endpoint (Story 3.1 complete)

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Completion Status

✅ COMPLETE - useRecommendation hook created with full API integration

### Completion Notes

- Created useRecommendation hook with POST to /api/recommend endpoint
- Integrates with RecommendationContext for shared state management
- Request/response validation with comprehensive error handling
- Optimistic UI updates with configurable stage timings
- Stage progression: Data Interpretation (2.5s) → Plan Scoring (4s) → Narrative Generation (2.5s)
- Retry capability with max attempt tracking
- Abort controller for request cancellation
- Cleanup on unmount (timers, fetch requests)
- TypeScript strict mode with full type safety
- Returns: submit, result, stages, loading, error, retryCount, reset

### File List

- `/Users/abdul/Downloads/Projects/EnergyGenius/src/ui/hooks/useRecommendation.ts` (created)

### Change Log

- Created useRecommendation hook with full API integration
- Implemented optimistic stage updates with configurable timings
- Added request/response validation
- Added error handling with retry logic
- Added cleanup on unmount
- Integrated with existing RecommendationContext

---

## QA Results

**Status:** PENDING (awaiting development)

**Gate Decision:** READY FOR DEVELOPMENT - Story 5.4 acceptance criteria complete
